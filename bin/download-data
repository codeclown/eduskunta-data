#!/usr/bin/env node

const request = require('request-promise');
const getDb = require('../src/server/db');
const insertIntoDb = require('../src/server/utils/insertIntoDb');

const { tables } = require('../src/server/schema.json');

const db = getDb();

getRowCountEstimates()
  .then(estimates => Promise.all(
    tables
      // whitelist for now as we don't need everything
      .filter(table => table.tableName === 'MemberOfParliament')
      .map(table => indexTable(table, estimates))
  ))
  .catch(error => {
    if (error.meta) {
      console.error(error.meta.body);
    } else {
      console.error(error.stack);
    }
    process.exit(1);
  });

function getRowCountEstimates() {
  return request({
    method: 'GET',
    url: 'https://avoindata.eduskunta.fi/api/v1/tables/counts',
    json: true
  });
}

function indexTable(table, estimates) {
  const { tableName, indexName, primaryKey, columns } = table;
  const rowCountEstimate = estimates.find(item => item.tableName === tableName).rowCount;

  return db('lastBatchImportId')
    .where('tableName', tableName)
    .first('lastId')
    .then(result => {
      if (typeof result === 'undefined') {
        return db('lastBatchImportId')
          .insert({
            tableName,
            lastId: '1'
          })
          .then(() => {
            return '1';
          });
      }
      return result.lastId;
    })
    .then(lastId => {
      console.error(`[${tableName}] rowCountEstimate: ${rowCountEstimate} lastId: ${lastId}`);

      return getData(lastId, 0);
    });

  function getData(lastId, requests) {
    const url = `https://avoindata.eduskunta.fi/api/v1/tables/${tableName}/batch?perPage=100&pkStartValue=${parseInt(lastId) + 1}&pkName=${encodeURIComponent(primaryKey)}`;
    return request({ url, json: true })
      .then(({ columnNames, hasMore, pkLastValue, rowData }) => {
        if (!rowData.length) {
          console.error(`[${tableName}] reached the end, no more results`);
          return;
        }

        const rowObjects = rowData.map(row => row.reduce((obj, value, index) => {
          obj[columnNames[index]] = value;
          return obj;
        }, {}));

        // When listing reaches the end, this is null... let's manually grab the latest one
        if (pkLastValue === null) {
          pkLastValue = Math.max.apply(null, rowObjects.map(row => parseInt(row[primaryKey])));
        }
        pkLastValue = pkLastValue.toString();

        return db.transaction(trx =>
          insertIntoDb(trx, table, rowObjects)
            .then(() => {
              if (requests % 10 === 0) {
                return trx(tableName).count(primaryKey, { as: 'amount' })
                  .then(results => results[0].amount)
                  .then(amount => {
                    console.error(`[${tableName}] indexed results: ${amount} / ${rowCountEstimate}`);
                  });
              }
            })
            .then(() => {
              return trx('lastBatchImportId')
                .where('tableName', tableName)
                .update({
                  lastId: pkLastValue
                });
            })
        ).then(() => {
          if (hasMore) {
            return getData(pkLastValue, requests + 1);
          }
        });
      });
  }
}
