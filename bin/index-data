#!/usr/bin/env node

const request = require('request-promise');
const { Client } = require('@elastic/elasticsearch');

const client = new Client({ node: 'http://localhost:9200' });

const { tables } = require('../src/schema.json');

getRowCountEstimates()
  .then(estimates => Promise.all([
    indexTable(tables.find(({ tableName }) => tableName === 'SaliDBAanestys'), estimates),
    indexTable(tables.find(({ tableName }) => tableName === 'SaliDBAanestysEdustaja'), estimates)
  ]))
  // .then(estimates => Promise.all(tables.map(table => indexTable(table, estimates))))
  .catch(error => {
    if (error.meta) {
      console.error(error.meta.body);
    } else {
      console.error(error.stack);
    }
    process.exit(1);
  });

function getRowCountEstimates() {
  return request({
    method: 'GET',
    url: 'http://avoindata.eduskunta.fi/api/v1/tables/counts',
    json: true
  });
}

function indexTable({ tableName, indexName, primaryKey, columns }, estimates) {
  const rowCountEstimate = estimates.find(item => item.tableName === tableName).rowCount;

  return client.search({
    index: indexName,
    body: {
      aggs: {
        max_id: {
          max: { field: 'remoteId' }
        }
      },
      size: 0
    }
  })
    .then(({ body }) => body.aggregations.max_id.value)
    .catch(error => {})
    .then(maxId => {
      const pkStartValue = maxId || 1;

      console.error(`[${tableName}] rowCountEstimate: ${rowCountEstimate} pkStartValue: ${pkStartValue}`);

      return getData(pkStartValue, 0);
    });

  function getData(pkStartValue, requests) {
    const url = `http://avoindata.eduskunta.fi/api/v1/tables/${tableName}/batch?perPage=100&pkStartValue=${pkStartValue}&pkName=${encodeURIComponent(primaryKey)}`
    return request({ url, json: true })
      .then(({ columnNames, hasMore, pkLastValue, rowData }) => {
        const operations = rowData.reduce((operations, row) => {
          const doc = columnNames.reduce((obj, columnName, index) => {
            obj[columnName] = row[index];

            if (columnName === primaryKey) {
              obj['remoteId'] = parseInt(row[index]);
            }

            const { columnType } = columns.find(column => column.columnName === columnName);
            if (columnType === 'date') {
              obj[`${columnName}AsDate`] = new Date(row[index]);
            }

            return obj;
          }, {});

          return operations.concat([
            { index: { _index: indexName } },
            doc
          ]);
        }, []);

        return client.bulk({
          body: operations
        }).then(bulkResponse => {
          // bulkResponse.body.items.forEach(console.log);
          // return;
          if (bulkResponse.body.errors) {
            // console.error(`[${tableName}] Errors while indexing:`);
            bulkResponse.body.items.filter(item => item.create.error).forEach(item => {
              if (item.create.error.reason.indexOf('version conflict, document already exists') >= 0) {
                // no big deal
                return;
              }
              console.error(`[${tableName}]`, item.create.error);
            });
          }

          if (requests % 10) {
            return client.indices.refresh({ index: indexName })
              .then(() => client.count({ index: indexName }))
              .then(({ body }) => {
                console.error(`[${tableName}] indexed results: ${body.count} / ${rowCountEstimate}`);
              });
          }
        }).then(() => {
          if (hasMore) {
            return getData(parseInt(pkLastValue) + 1, requests + 1);
          }
        });
      });
  }
}
